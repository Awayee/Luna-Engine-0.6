// Copyright 2018-2020 JXMaster. All rights reserved.
/*
* @file Input.hpp
* @author JXMaster
* @date 2019/7/24
*/
#pragma once
#include <Core/Core.hpp>
#include "IInputDevice.hpp"
#include "IMouse.hpp"
#include "IKeyboard.hpp"
#include "IController.hpp"

#ifndef LUNA_INPUT_API
#define LUNA_INPUT_API
#endif

namespace luna
{
	//! The input module  represents the global input system. The input system provides access directly to the platform's input 
	//! device like mouse, keyboard, controller, touch, sensors and so on, it is designed to be working close to the OS layer and does not provide 
	//! high-level abstractions like custom actions, key-mappings and so on.
	//! 
	//! The input system is formed by three parts: input device, input system and input device event queue, and only the former two parts will be used
	//! in polling mode. The input device is the "driver" for input system, it fetches the input from the underlying system/platform and provides the 
	//! input data to the user. The input device must be mounted to the input system before it can be read by user. The global input system instance 
	//! keeps a list of all input devices mounted so that they can be fetched by user. 
	//! 
	//! When the input system initializes, it automatically detects the underlying system for all available input devices and mounts 
	//! them to the input system. Note that the devices the input system detects is not the physical input device, but their driver files, 
	//! so for example, the "controller" device will exist in all Windows platforms even though they may not has a real XBOX device controller 
	//! attached to computer, so long as XInput driver library exists. This makes hot plug-in available.
	//! 
	//! The input system works in two modes: pooling mode and event mode. Pooling mode tracks the state of the input device, like if the button 
	//! is pressed now, or reads the degree of the pressure value from pen tablet, this is considered to be a "raw input" mode and can be done 
	//! directly by querying the device for the data. Event mode tracks the state change of the input device, and sends events if some change has 
	//! happened.
	//! To use event mode, however, the user should create an input event queue from the supported device, and the event messages are sent to 
	//! the event queue, the user reads and handles the input based on its own strategy, this is considered to be a "buffered input" and may have 
	//! some delay between the time the event occurs and the time the user handles the event.
	//! 
	//! Note that since the input system cannot really accepts hardware interruption to be informed of an input event (because this is happed in 
	//! kernel space of the operating system), all input devices are actually fetching input events from OS in a regular time basis, and 
	//! this is happened when `IInput::update` is called. If the event is not generated by system, but by the device itself (like comparing the 
	//! input state of this update and last update to determine if it is changed), all state changed between two update calls except the last change
	//! will be ignored. This may cause problems if your program's FPS is really low.
	//! 
	//! Also note that in a regular multi-window system like Windows, Linux or MacOS, two set of input APIs are provided: one is application-based
	//! and one is window-based. The application-based input APIs will continue to receive inputs even through all windows of the application is
	//! hided from the screen, and the window-based input APIs will receive inputs only when the window is foregrounded by user or "capturing" the 
	//! input devices like mouse or keyboard. All input devices the input system natively provides are application-based, and there is usually one 
	//! special input device registered by the Gfx module called "window" to let user handling events in window-based APIs. In single-window 
	//! systems like most mobile and console systems, application-based and window-based APIs exist but do not differ because one application is 
	//! represented by only one window, and the application does not have permissions to access to the system input when the application is running in 
	//! background.
	namespace input
	{
		constexpr Guid input_domain{ "{e9a5a195-73a4-4daa-b07d-9f381a860cbc}" };

		//! Failed to read from the device because the specified input device is not connected.
		constexpr result_t e_input_device_not_connected = e_user_failure - 1;

		LUNA_INPUT_API RV init();

		//! Updates the state of all input devices to let them dispatch input messages to input handlers.
		LUNA_INPUT_API void update();

		//! Gets a list of all registered input devices.
		LUNA_INPUT_API Vector<P<IName>> get_devices();

		//! Gets an input device to read input events from it.
		LUNA_INPUT_API RP<IInputDevice> get_device(IName* device_name);

		//! Mounts one device to the input system. The input system keeps a strong reference to the input
		//! system until it is unmounted.
		LUNA_INPUT_API RV mount_device(IName* device_name, IInputDevice* device);

		//! Unmounts one device from the system.
		LUNA_INPUT_API RV unmount_device(IName* device_name);
	}
}